\documentclass{article}
\usepackage[utf8]{inputenc}
% \usepackage{polski}
\usepackage[]{amsthm}
\usepackage[]{amssymb} %gives us the character \varnothing

\usepackage{hyperref}
\usepackage{titling}
\usepackage[backend=bibtex]{biblatex}
\addbibresource{mybib.bib}
\theoremstyle{definition}
\newtheorem{definition}{Definition}

\theoremstyle{lemma}
\newtheorem{lemma}{Lemma}

\theoremstyle{observation}
\newtheorem{observation}{Observation}

\theoremstyle{theorem}
\newtheorem{theorem}{Theorem}

\newcommand*{\fullref}[1]{\hyperref[{#1}]{\autoref*{#1} \nameref*{#1}}}


\title{Continuation Passing Style for Effect Handlers}
\author{Mateusz Urba≈Ñczyk}
\date{7 January 2020}

\begin{document}
\maketitle

\begin{abstract}

    We provide an implementation of algebraic effects and handlers by doing continuation
    passing style tranformation of the functional programming language Freak,
    which is based on the existing Links langauge \cite{handlers-cps}.

\end{abstract}

\section{Introduction}

In this article we present experimental programming language Freak, which is an
implementation of Continuation Passing Style for Effect Handlers paper \cite{handlers-cps},
with addition of a few basic constructs. We start by presenting the related work,
then discuss syntax and operational semantics. Basic usage guide for playing with
the language is provided, as well as implementation details and examples. We conclude
by stating what are the possible augmentations, that are intended to be made in the future.

\section{State of the art}

    Despite from Links language \cite{handlers-cps}, on which the implementation
    is based, there are currently many other alternatives available. One may take
    a look at Frank \cite{frank}, which provides a support for multihandlers,
    Koka \cite{leijen-koka}, Helium \cite{helium} or Eff \cite{eff}. Except from
    separate languages, many libraries arose for existing ones like Haskell,
    Idris, Scala or Multicore OCaml. \\

    As can be seen in the J. Yallop repository \cite{effects-bibliography},
    algebraic effects and handlers are now trending branch of computer science.

\section{Syntax}

\section{Operational semantics}

    The source language's dynamics has been described
    extensively by providing small-step operational semantics,
    continuation passing style transformation \cite{handlers-cps} as well
    as abstract machine \cite{liberating-effects}, which was proved to coincide
    with CPS translation. That being said, Freak introduces new basic
    constructs to the language, for which we shall define the semantics.

    \subsection{Integers}

    \subsection{Binary operators}


\section{Usage guide}
    % TODO: not sure if correct place for that

    All commands are available within \verb src  directory.

    \subsection{Build and install}

    \begin{itemize}
        \item Install dependencies: \verb!make install!
        \item Compile: \verb!make build!
        \item Link to PATH: \verb!sudo make link!
        \item Remove artiacts: \verb!make clean!
    \end{itemize}

    After compiling and linking program to PATH, one may evaluate program as
    follows: \verb!freak programs/choicesList.fk!. The actual code is described in \fullref{sec:choice-example}

    \subsection{Running tests}

    Test cases are available \href{https://github.com/Tomatosoup97/freak/blob/master/src/Tests.hs}{\underline{here}},
    they include both inline and file-based tests. For more details about
    writing tests, one may refer to \textit{HUnit documentation} \cite{hunit-docs}. \\

    \begin{itemize}
        \item Run tests: \verb!make tests!
        \item Run code linter: \verb!make lint!
        \item Compile, run linter and tests: \verb!make check!
    \end{itemize}

\section{Implementation}

    The Freak implementation is available at \href{https://github.com/Tomatosoup97/freak}{https://github.com/Tomatosoup97/freak}.
    While the paper provided a good overview on the language and the translation,
    the lower-level details were ommited. Therefore, the actual CPS implementation
    is based on A. Appel \cite{appel-continuations}, which provides a translation
    for a simplified ML calculus. \\

    The core data structure into which the source program is transformed,
    the \verb!Continuation Computation!, is defined as follows:

    \begin{verbatim}
data ContComp
    = CPSApp CValue [CValue]
    | CPSFix Var [Var] ContComp ContComp
    | CPSBinOp BinaryOp CValue CValue Var ContComp
    | CPSValue CValue
    | CPSLet Var CValue ContComp
    | CPSSplit Label Var Var CValue ContComp
    | CPSCase CValue Label Var ContComp Var ContComp
    | CPSIf CValue ContComp ContComp
    | CPSAbsurd CValue
    \end{verbatim}

    The translation is based on the curried first-order translation. For
    improving the performance of the evaluation, uncurried higher-order translation
    should be adopted, so that administrative redexes are contracted and
    proper tail-recursion is obtained. The final answer is represented as a \verb!DValue!,
    where the meaning of the coproduct is as one would expect:

    \begin{verbatim}
type Label = String

data DValue
    = DNum Integer
    | DLambda Env FuncRecord
    | DUnit
    | DPair DValue DValue
    | DLabel Label
    \end{verbatim}


    \subsection{Type inference}

    Type system as of this day is not implemented, as the focus has been put
    on CPS transformation. Further work is required here, especially considering
    the fact that a huge advantage of algebraic effects is that they are explicitly
    defined in the type of a computation.

    \subsection{Source code structure}

    The source code is divided into a number of modules, each with a different
    responsibility.

    \begin{verbatim}
    AST.hs          - AST data structures
    CPS.hs          - CPS translation
    Eval.hs         - Evaluation of the target calculus
    Freak.hs        - API for the language
    Main.hs         - Main module running evaluator on given filename
    Parser.hs       - Parser and lexer
    Tests.hs        - Tests module
    Typechecker.hs  - -- suspended --
    Types.hs        - Common types definition
    programs/       - Exemplary programs used in tests
    \end{verbatim}

\section{Examples}

    In this section we present a few examples to show the capabilities of the
    language. The ideas has been based on \cite{programming-in-eff}, and thus will not be
    described in great details. More exemplary programs in Freak language can
    be found \href{https://github.com/Tomatosoup97/freak/tree/master/src/programs}{\underline{here}}.

    \subsection{Choice}
    \label{sec:choice-example}

    The first example will be based on modelling (nondeterministic) choice
    in the program. We will make two decisions, which will affect the computation
    result:

    \begin{verbatim}
    let c1 <- do Choice () in
    let c2 <- do Choice () in
    let x <- if c1 then return 10 else return 20 in
    let y <- if c2 then return 0 else return 5 in
        return x - y
    \end{verbatim}

    With that in hand, we may want to define effect handlers:

    \begin{verbatim}
    handle ... with {
        Choice p r ->
            let t <- r 1 in
            let f <- r 0 in
            <PLACEHOLDER> |
        return x -> return x
    }
    \end{verbatim}

    where in the \verb!<PLACEHOLDER>! we can define on what to do with the
    computation. For example, min-max strategy for picking the minimum value:

    \begin{verbatim}
    if t < f then return t else return f
    \end{verbatim}

    where the code evaluates to \verb!5!. Another example is a handler that
    collects all possible results, which can be achieved by putting
    \verb!return (t, f)! in the \verb!<PLACEHOLDER>!, which evaluates to \verb!((10, 5), (20, 15))!.

    \subsection{Exceptions}

    Exceptions are simply algebraic effect handlers which drop the resumption.

    \begin{verbatim}
    handle
        if x == 0 then do ZeroDivisionError ()
                  else return 1/x
    with {
        ZeroDivisionError p r -> return 42 |
        return x -> return x
    }
    \end{verbatim}
    Where we imagine that x variable has been bound previously.

\section{Future work}

    The Freak language is experimental and a lot of possible enhancements
    could be adopted. Here we provide a list of proposed directions in which
    further work could be made.

    \subsection{Alternative evaluation}

    The Links language also provides small-step operational semantics and
    an abstract machine \cite{liberating-effects}. Implementing another way
    of evaluation could serve as a way to empirically assert correctness,
    as opposed to formally.

    \subsection{Make the langugae more usable}

    While the language is turing-complete, for convenient usage it
    requires more basic constructs and syntactic sugar for common patterns
    that would ease the programming.

    \subsection{Multiple instances of algebraic effect}

    The Freak language is limited to a single instance of an effect. We would
    need to support cases where many instances of the algebraic effects, with
    the same handlers code, could be instantiated. The current state of the
    art introduces a concept of resources and instances, as in Eff \cite{programming-in-eff},
    or instance variables, as in Helium \cite{binders-labels}.

    \subsection{Selective CPS}

    Other languages, like Koka \cite{leijen-koka}, or even core of the Links, are
    performing selective CPS translation, which reduces the overhead on code
    that does not perform algebraic effects. Our current translation is fully
    embeded in the CPS.

    \subsection{Exceptions as separate constructs}

    Exceptions are a trivial example of algebraic effect where the resumption is
    discarded, and as described in \S 4.5 \cite{handlers-cps}, they can be modeled
    as a separate construct to improve performance.

    \subsection{Shallow handlers}

    Shallow and deep handlers while being able to simluate each other up to
    administrative reductions, have a very different meaning from a theoretical
    point of view. Implementing them as defined by Lindley et al. \cite{shallow-handlers} could
    be another way of enhancing Freak.

\section{Conclusions}

\printbibliography

\end{document}
